# -*- coding: utf-8 -*-
"""TSP_GA.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1bc609TJX7umbuQIFadSqH7rKnippg988

#TSP using Genetic algorithm

Problem definition:
  There are 'n' cities and cost to travel from city i->j is given. There is sales man who want cover all the cities. So devise a route such that the cost is as low as possible.
Constraint : Every cities must be visted only once.

Solution:
  This is a optimization problem. In this solution we use genetic algorithm to find the optimal path. Genetic is a non-derivative approach to solve a optimization problem. Though its not guaranteed to find the most low cost path, it can provide a path with optimal cost(soft computing). This is usually employeed to solve NP problems.

Following are the steps to take:
Finding relation between phenotypes and genotypes for this problem,i.e encoding and decoding.
Finding the appropriate fitness function.
Generating intial population.
Finding suitable selection, crossover and mutation method.
Choosing appropriate survivor selection method and termination condition.

IN THIS FILE
Encoding         : Permutation Encoding 
Fitness function : Cost
Selection        : Roulette Wheel Selection
Crossover        : Ordered Crossover
Mutation         : Interchange
"""

#The libraries used in this problem
import numpy as np
import copy
from random import shuffle
from random import randrange
import matplotlib.pyplot as plt
from IPython.display import clear_output

#Defining city graph
n=10 #No of cities
cities=[i for i in range(n)]
graph=np.random.randint(1,100,(n,n))#graph[i][j] tells the cost to travel i->j
for i in range(n):
  graph[i][i]=0
print(graph)

#Defining chromosome
class chromosome:
  def __init__(self,data,fit):
    self.data=np.asarray(data)
    self.fit=fit

#Defining fitness function
def fitness(data):
  cost=0
  for i in range(len(data)-1):
    cost+=graph[data[i]][data[i+1]]
  return cost #Fitness value

#Roulette Wheel Selection
def selection(population,fitness_data,noc):
  total=sum(fitness_data)
  inverse=list(map(lambda x:total-x,fitness_data))
  total=sum(inverse)
  probability=list(map(lambda x:x/total,inverse))
  parents=np.random.choice(population,(noc,2),False,p=probability) #Gives noc pairs of identical parents from population, selected with given probability
  return parents

#Ordered crossover
def crossover(parents):
  children=np.full((parents.shape[0],2,n),n)
  for i,j in enumerate(parents):
    low=randrange(n)
    high=randrange(low,n)  
    children[i][0][low:high]=j[0].data[low:high]
    children[i][1][low:high]=j[1].data[low:high]
    pointer_list=[x for x in range(n) if x not in range(low,high)]
    for l in [0,1]:
      ptr=0
      array=np.concatenate((j[l].data[:low],j[l].data[high:]))
      for k in array:
        if k not in children[i][1-l][:]:
          children[i][1-l][pointer_list[ptr]]=k
          ptr+=1
      for m in j[l].data[low:high]:
        if m not in children[i][1-l][:]:
          children[i][1-l][pointer_list[ptr]]=m
          ptr+=1
  return children.reshape(-1,n)

#Interchange mutation
def mutation(children,nom):
  main_index=np.random.randint(0,children.shape[0],nom)
  for j in range(main_index):
    indices=np.random.randint(0,n,2)
    children[j][indices[0]],children[j][indices[1]]=children[j][indices[1]],children[j][indices[0]]
  return children

#Max fit survives
def survivor_selection(population,fitness_data_parent,children):
  fitness_data_children=list(map(lambda x:fitness(x),children))
  children_chormosome=[]
  for i,j in enumerate(children.tolist()):
    children_chormosome.append(chromosome(j,fitness_data_children[i]))
  all_combine=population+children_chormosome
  all_fitness_combine=fitness_data_parent+fitness_data_children
  for i in range(len(all_combine)-len(population)):
    index=all_fitness_combine.index(max(all_fitness_combine))
    del all_fitness_combine[index],all_combine[index]
  return all_combine,all_fitness_combine

def train_setup(population_count=10,no_gen=10,noc=3,nom=1,verbose=True):
  #Initial poupulation
  population=[]
  fitness_data=[]
  for i in range(population_count):
    shuffle(cities)
    data=copy.deepcopy(cities)
    fitness_data.append(fitness(data))
    population.append(chromosome(data,fitness_data[-1]))
  
  #Evolution process
  overall_best_fit=min(fitness_data)
  best_chromosome=population[fitness_data.index(overall_best_fit)]
  avg_fitness=[sum(fitness_data)/len(fitness_data)]
  min_fitness=[overall_best_fit]
  max_fitness=[max(fitness_data)]


  for i in range(no_gen):
    parents=selection(population,fitness_data,noc)
    children=crossover(parents)
    mutated=mutation(children,nom)
    population,fitness_data=survivor_selection(population,fitness_data,mutated)
    
    #Recording
    current_generation_best=min(fitness_data)
    average=sum(fitness_data)/len(fitness_data)
    max_fitness.append(max(fitness_data))
    min_fitness.append(current_generation_best)
    avg_fitness.append(average)
    if current_generation_best<overall_best_fit:
      overall_best_fit=current_generation_best
      best_chromosome=population[fitness_data.index(current_generation_best)]
    
    #Details of evolution
    if verbose:
      clear_output(wait=True)
      print("Generation : ",i+1)
      print("Overall best fit : ",overall_best_fit)
      print("Current best fit : ",current_generation_best)
      print("Current avg : ",average)
      plt.plot(min_fitness,'g',label="MIN")
      plt.plot(avg_fitness,'b',label="AVG")
      plt.plot(max_fitness,'r',label="MAX")
      plt.xlabel("Generation")
      plt.ylabel("Fitness")
      plt.legend(loc="best")
      plt.show()
  return population,best_chromosome


#Evolution
final=train_setup()

